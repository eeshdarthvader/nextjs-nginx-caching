proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=STATIC:10m inactive=7d use_temp_path=off;

upstream nextjs_upstream {
  server nextjs:3000;
  # We could add additional servers here for load-balancing
}

server {
  listen 80 default_server;

  server_name _;

  server_tokens off;

  proxy_http_version 1.1;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection 'upgrade';
  proxy_set_header Host $host;
  proxy_cache_bypass $http_upgrade;


	location /_next/static {
    proxy_cache STATIC;
    proxy_pass http://nextjs_upstream;

    # For testing cache - remove before deploying to production
    add_header X-Cache-Status $upstream_cache_status;
  }

# Next.js handles setting headers for browser caching. For the built static assets at /_next/static/*, the url has a unique build ID in it so the browser cache headers are set to cache forever. If you rebuild the app, the url will be different and so the browser will actually be requesting a different resource.

# However, with the static assets in the static/ directory, there is no build ID. They are just made available at the /static/* path unchanged. Therefore, Next.js sets no-cache headers for these assets so the browser never caches them. If the assets change, the url remains the same so we donâ€™t want our users to have out-of-date assets.

# The problem is that NGINX respects these headers and, therefore, will not actually cache these files by default.

# We can get around this by telling NGINX to ignore the Cache-Control headers from our proxied Next.js app


		# For testing cache - remove before deploying to production
		add_header X-Cache-Status $upstream_cache_status;
	}

  location / {
    proxy_pass http://nextjs_upstream;
  }
}

